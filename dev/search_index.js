var documenterSearchIndex = {"docs":
[{"location":"genes/#Filtering:-the-@genes-macro-1","page":"Filtering: the @genes macro","title":"Filtering: the @genes macro","text":"","category":"section"},{"location":"genes/#","page":"Filtering: the @genes macro","title":"Filtering: the @genes macro","text":"A useful tool provided by GenomicAnnotations is the macro @genes. It is used to filter through annotations, for example to look at only at coding sequences or rRNAs, which can then be modified or iterated over:","category":"page"},{"location":"genes/#","page":"Filtering: the @genes macro","title":"Filtering: the @genes macro","text":"# Print locus tags of all coding sequences longer than 1000 nt, that are not pseudo genes\nfor gene in @genes(chr, iscds, length(gene) > 1000, ! :pseudo)\n    println(gene.locus_tag)\nend","category":"page"},{"location":"genes/#","page":"Filtering: the @genes macro","title":"Filtering: the @genes macro","text":"@genes","category":"page"},{"location":"genes/#GenomicAnnotations.@genes","page":"Filtering: the @genes macro","title":"GenomicAnnotations.@genes","text":"@genes(chr, exs...)\n\nIterate over and evaluate expressions in exs for all genes in chr.genes, returning genes where all expressions evaluate to true. Any given symbol s in the expression will be substituted for gene.s. The gene itself can be accessed in the expression as gene. Accessing properties of the returned list of genes returns a view, which can be altered.\n\nSymbols and expressions escaped with Ref() will be ignored.\n\nSome short-hand forms are available to make life easier:     CDS, rRNA, and tRNA expand to feature(gene) == \"...\",     get(s::Symbol, default) expands to get(gene, s, default)\n\nExamples\n\njulia> chromosome = readgbk(\"example.gbk\")\nChromosome 'example' (5028 bp) with 6 annotations\n\njulia> @genes(chromosome, iscds) |> length\n3\n\njulia> @genes(chromosome, length(gene) < 500)\n     CDS             3..206\n                     /db_xref=\"GI:1293614\"\n                     /locus_tag=\"tag01\"\n                     /codon_start=\"3\"\n                     /product=\"TCP1-beta\"\n                     /protein_id=\"AAA98665.1\"\n\njulia> @genes(chromosome, ismissing(:gene)) |> length\n2\n\njulia> @genes(chromosome, ismissing(:gene)).gene .= \"Unknown\";\n\njulia> @genes(chromosome, ismissing(:gene)) |> length\n0\n\nAll arguments have to evaluate to true for a gene to be included, so the following expressions are equivalent:\n\n@genes(chr, feature(gene) == Ref(:CDS), length(gene) > 300)\n@genes(chr, (feature(gene) == Ref(:CDS)) && (length(gene) > 300))\n\n@genes returns a Vector{Gene}. Attributes can be accessed with dot-syntax, and can be assigned to\n\n@genes(chr, :locus_tag == \"tag03\")[1].pseudo = true\n@genes(chr, CDS, ismissing(:gene)).gene .= \"unknown\"\n\n\n\n\n\n","category":"macro"},{"location":"accessing/#Accessing-and-modifying-annotations-1","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"","category":"section"},{"location":"accessing/#Feature-1","page":"Accessing and modifying annotations","title":"Feature","text":"","category":"section"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"Features (genes) can be added using addgene!. A feature must have a feature name and a locus (position), and can have any number of additional qualifiers associated with it (see next section).","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"addgene!","category":"page"},{"location":"accessing/#GenomicAnnotations.addgene!","page":"Accessing and modifying annotations","title":"GenomicAnnotations.addgene!","text":"addgene!(chr::Chromosome, feature, locus; kw...)\n\nAdd gene to chr. locus can be a Locus, a UnitRange, or a StepRange (for decreasing ranges, which will be annotated on the complementary strand).\n\nExample\n\naddgene!(chr, \"CDS\", 1:756;\n    locus_tag = \"gene0001\",\n    product = \"Chromosomal replication initiator protein dnaA\")\n\n\n\n\n\n","category":"function"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"After adding a new feature, sort! can be used to make sure that the annotations are stored (and printed) in the order in which they occur on the chromosome:","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"sort!(chr)","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"Existing features can be removed using delete!:","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"delete!(::Gene)\ndelete!(::AbstractVector{Gene})","category":"page"},{"location":"accessing/#Base.delete!-Tuple{Gene}","page":"Accessing and modifying annotations","title":"Base.delete!","text":"delete!{T}(h::MutableBinaryHeap{T}, i::Int)\n\nDeletes the element with handle i from heap h .\n\n\n\n\n\ndelete!(collection, key)\n\nDelete the mapping for the given key in a collection, and return the collection.\n\nExamples\n\njulia> d = RobinDict(\"a\"=>1, \"b\"=>2)\nRobinDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> delete!(d, \"b\")\nRobinDict{String,Int64} with 1 entry:\n  \"a\" => 1\n\n\n\n\n\ndelete!(gene::AbstractGene)\n\nDelete gene from parent(gene). Warning: does not work when broadcasted! Use delete!(::AbstractVector{Gene}) instead.\n\n\n\n\n\n","category":"method"},{"location":"accessing/#Base.delete!-Tuple{AbstractArray{Gene,1}}","page":"Accessing and modifying annotations","title":"Base.delete!","text":"delete!(genes::AbstractArray{Gene, 1})\n\nDelete all genes in genes from parent(genes[1]).\n\nExample\n\ndelete!(@genes(chr, length(gene) <= 60))\n\n\n\n\n\n","category":"method"},{"location":"accessing/#Qualifiers-1","page":"Accessing and modifying annotations","title":"Qualifiers","text":"","category":"section"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"Features can have multiple qualifiers, which can be modified using Julia's property syntax:","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"# Remove newspace from gene product descriptions\nfor gene in @genes(chr, iscds)\n    replace!(gene.product, '\\n' => ' ')\nend","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"Properties also work on views of genes, typically generated using @genes:","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"interestinggenes = readlines(\"/path/to/list/of/interesting/genes.txt\")\n@genes(chr, iscds, :locus_tag in interestinggenes).interesting .= true","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"Sometimes features have multiple instances of the same qualifier, such genes having several EC-numbers. Assigning qualifiers with property syntax overwrites any data that was previously stored for that feature, and trying to assign a vector of values to a qualifier that is currently storing scalars will result in an error, so to safely assign qualifiers that might have more instances one can use pushproperty!:","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"pushproperty!","category":"page"},{"location":"accessing/#GenomicAnnotations.pushproperty!","page":"Accessing and modifying annotations","title":"GenomicAnnotations.pushproperty!","text":"pushproperty!(gene::AbstractGene, qualifier::Symbol, value::T)\n\nAdd a property to gene, similarly to Base.setproperty!(::gene), but if the property is not missing in gene, it will be transformed to store a vector instead of overwriting existing data.\n\njulia> eltype(chr.genedata[!, :EC_number])\nUnion{Missing,String}\n\njulia> chr.genes[1].EC_number = \"EC:1.2.3.4\"\n\"EC:1.2.3.4\"\n\njulia> pushproperty!(chr.genes[1], :EC_number, \"EC:4.3.2.1\"); chr.genes[1].EC_number\n2-element Array{String,1}:\n \"EC:1.2.3.4\"\n \"EC:4.3.2.1\"\n\njulia> eltype(chr.genedata[!, :EC_number])\nUnion{Missing, Array{String,1}}\n\n\n\n\n\n","category":"function"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"Accessing properties that haven't been stored will return missing. For this reason, it often makes more sense to use get() than to access the property directly.","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"# chr.genes[2].pseudo returns missing, so this will throw an error\nif chr.genes[2].pseudo\n    println(\"Gene 2 is a pseudogene\")\nend\n\n# ... but this works:\nif get(chr.genes[2], :pseudo, false)\n    println(\"Gene 2 is a pseudogene\")\nend","category":"page"},{"location":"accessing/#Sequences-1","page":"Accessing and modifying annotations","title":"Sequences","text":"","category":"section"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"The sequence of a Chromosome chr is stored in chr.sequence. Sequences of individual features can be read with sequence:","category":"page"},{"location":"accessing/#","page":"Accessing and modifying annotations","title":"Accessing and modifying annotations","text":"sequence(::Gene)","category":"page"},{"location":"accessing/#GenomicAnnotations.sequence-Tuple{Gene}","page":"Accessing and modifying annotations","title":"GenomicAnnotations.sequence","text":"sequence(gene::AbstractGene)\n\nReturn genomic sequence for gene.\n\nExample\n\nThe following code will write the translated sequences of all genes in chr to a file:\n\nusing FASTX\nwriter = FASTA.Writer(open(\"proteins.fasta\", \"w\"))\nfor gene in @genes(chr, iscds)\n    aaseq = translate(sequence(gene))\n    write(writer, FASTA.record(gene.locus_tag, get(gene, :product, \"\"), aaseq))\nend\nclose(writer)\n\n\n\n\n\n","category":"method"},{"location":"#GenomicAnnotations.jl-1","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"","category":"section"},{"location":"#Description-1","page":"GenomicAnnotations.jl","title":"Description","text":"","category":"section"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"GenomicAnnotations is a package for reading, modifying, and writing genomic annotations in the GenBank format.","category":"page"},{"location":"#Installation-1","page":"GenomicAnnotations.jl","title":"Installation","text":"","category":"section"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"julia>]\npkg> add GenomicAnnotations","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"or","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"using Pkg\nPkg.add(\"GenomicAnnotations\")","category":"page"},{"location":"#Examples-1","page":"GenomicAnnotations.jl","title":"Examples","text":"","category":"section"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"GenBank files are read with readgbk(pathtofile), which returns a vector of Chromosomes. gbkfile can be gzipped as long as the filename ends in \".gz\". If we're only interested in the first chromosome in example.gbk we only need to store the first element.","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"chr = readgbk(\"test/example.gbk\")[1]","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"Chromosomes have five fields, name, header, genes, genedata, and sequence. The name is read from the header, which is stored as a string. The annotation data is stored in genedata, but generally you should use genes to access that data. For example, it can be used to iterate over annotations, and to modify them.","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"for gene in chr.genes\n    gene.locus_tag = \"$(chr.name)_$(gene.locus_tag)\"\nend\n\nchr.genes[2].locus_tag = \"test123\"","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"The macro @genes can be used to filter through the annotations. The keyword gene is used to refer to the individual Genes. @genes can also be used to modify annotations.","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"@genes(chr, length(gene) > 300) # Returns all features longer than 300 nt","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"Gene sequences can be accessed with sequence(gene). For example, the following code will write the translated sequences of all protein-coding genes to a file:","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"using FASTX\nwriter = FASTA.Writer(open(\"proteins.fasta\", \"w\"))\nfor gene in @genes(chr, iscds)\n    aaseq = translate(sequence(gene))\n    write(writer, FASTA.record(gene.locus_tag, get(gene, :product, \"\"), aaseq))\nend\nclose(writer)","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"Genes can be added using addgene!, and sort! can be used to make sure that the resulting annotations are in the correct order for printing. delete! is used to remove genes.","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"newgene = addgene!(chr, \"regulatory\", 670:677)\nnewgene.locus_tag = \"reg02\"\nsort!(chr.genes)\n\n# Genes can be deleted. This works for all genes where `:pseudo` is `true`, and ignores genes where it is `false` or `missing`\ndelete!(@genes(chr, :pseudo))\n# Delete all genes 60 nt or shorter\ndelete!(@genes(chr, length(gene) <= 60))","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"Individual genes, and Vector{Gene}s are printed in GBK format. To include the GBK header and the nucleotide sequence, printgbk(io, chr) can be used to write them to a file.","category":"page"},{"location":"#","page":"GenomicAnnotations.jl","title":"GenomicAnnotations.jl","text":"println(chr.genes[1])\nprintln(@genes(chr, iscds))\n\nopen(\"updated.gbk\", \"w\") do f\n    printgbk(f, chr)\nend","category":"page"},{"location":"io/#I/O-1","page":"I/O","title":"I/O","text":"","category":"section"},{"location":"io/#Input-1","page":"I/O","title":"Input","text":"","category":"section"},{"location":"io/#","page":"I/O","title":"I/O","text":"Annotation files are read with readgbk(pathtofile). Currently this assumes that the file follows standard GenBank format.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"readgbk(file)","category":"page"},{"location":"io/#GenomicAnnotations.readgbk-Tuple{Any}","page":"I/O","title":"GenomicAnnotations.readgbk","text":"readgbk(filename)\n\nParse GenBank-formatted file filename, returning a Vector{Chromosome}.\n\n\n\n\n\n","category":"method"},{"location":"io/#Output-1","page":"I/O","title":"Output","text":"","category":"section"},{"location":"io/#","page":"I/O","title":"I/O","text":"Annotations can be printed as with GenBank formatting using printgbk. In the REPL, instances of Gene are displayed as they would be in the annotation file.","category":"page"},{"location":"io/#","page":"I/O","title":"I/O","text":"printgbk","category":"page"},{"location":"io/#GenomicAnnotations.printgbk","page":"I/O","title":"GenomicAnnotations.printgbk","text":"printgbk([io], chr)\n\nPrint chr in GenBank format.\n\n\n\n\n\n","category":"function"}]
}
